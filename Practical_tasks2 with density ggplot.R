# Начнем с простого и вспомним, как применять логистическую регрессию в R.
# Напишите функцию get_coefficients, которая получает на вход dataframe
# с двумя переменными x ( фактор с произвольным числом градаций) и y
# ( фактор с двумя градациями). Функция строит логистическую модель, 
# где y — зависимая переменная, а x — независимая, и возвращает вектор со 
# значением экспоненты коэффициентов модели. 

test_data_01 <- read.csv("https://stepik.org/media/attachments/course/524/test_data_01.csv")

get_coefficients <- function(dataset){
  dataset$x <- as.factor(dataset$x)
  dataset$y <- as.factor(dataset$y)
  lg_res_01 <- glm(y ~ x, data=dataset, family = binomial)
  sapply(lg_res_01$coefficients, function(x) exp(x))
}
get_coefficients(test_data_01)


# Если в нашей модели есть количественные предикторы, то в интерцепте 
# мы будем иметь значение, соответствующее базовому уровню категориальных
# предикторов и нулевому уровню количественных. Это не всегда осмысленно. 
# Например, нам не интересен прогноз для людей нулевого возраста или роста.
# В таких ситуациях количественную переменную имеет смысл предварительно 
# центрировать так, чтобы ноль являлся средним значением переменной. 
# Самый простой способ центрировать переменную — отнять от каждого 
# наблюдения среднее значение всех наблюдений.
# В этом задании вашей задачей будет  написать функцию centered,
# которая получает на вход датафрейм и имена переменных, 
# которые необходимо центрировать так, как это описано выше.
# Функция должна возвращать этот же датафрейм, только 
# с центрированными указанными переменными.

test_data_02 <- read.csv("https://stepic.org/media/attachments/course/524/cen_data.csv")
var_names = c("X2")

centered <- function(test_data, var_names){
  test_data[var_names] <- apply(test_data[var_names], 2,
                                function(x) scale(x, center = TRUE, scale=FALSE))
  return(test_data)
}

centered(test_data, var_names)


# Представьте, что мы работаем в аэропорту в службе безопасности и 
# сканируем багаж пассажиров. В нашем распоряжении есть информация о
# результатах проверки багажа за предыдущие месяцы. Про каждую вещь мы знаем:
#     являлся ли багаж запрещенным - is_prohibited (No - разрешенный, Yes - запрещенный) 
#     его массу (кг) - weight
#     длину (см) - length
#     ширину (см) - width
#     тип багажа (сумка или чемодан) - type.
# Напишите функцию get_features , которая получает на вход набор данных о багаже.
# Строит логистическую регрессию, где зависимая переменная  - являлся ли багаж запрещенным,
# а предикторы - остальные переменные, и возвращает вектор с названиями 
# статистически значимых переменных (p < 0.05) (в модели без взаимодействия). 
# Если в данных нет значимых предикторов, функция возвращает строку с сообщением 
# "Prediction makes no sense".
#test_data_03 <- read.csv("https://stepic.org/media/attachments/course/524/test_luggage_1.csv")
test_data_03 <- data.frame(is_prohibited = factor( rep(1:2, each = 15)),weight = c( 82,78,75,82,78,76,86,81,80,81,84,84,80,75,72,81,74,75,84,86,90,80,84,64,79,82,79,79,80,86,82,78,75,82,78,76,86,81,80,81,84,84,80,75,72,81,74,75,84,86,90,80,84,64,79,82,79,79,80,86 ),length = c( 53,46,47,42,57,62,59,58,42,48,48,58,48,47,46,51,48,42,43,53,51,49,42,58,45,57,58,62,58,48,53,46,47,42,57,62,59,58,42,48,48,58,48,47,46,51,48,42,43,53,51,49,42,58,45,57,58,62,58,48 ),width = c( 21,18,20,21,24,21,19,22,18,20,21,19,21,19,21,22,20,21,20,18,18,20,21,16,21,19,23,21,21,21,21,18,20,21,24,21,19,22,18,20,21,19,21,19,21,22,20,21,20,18,18,20,21,16,21,19,23,21,21,21 ),type = factor(c( 1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2 )))


get_features <- function(dataset){
  dataset$is_prohibited <- as.factor(dataset$is_prohibited)
  dataset$type <- as.factor(dataset$type)
  lg_03 <- glm(is_prohibited ~ ., dataset, 
               family=binomial)
  an <- anova(lg_03, test='Chisq')
  if (length(rownames(subset(an,`Pr(>Chi)`<0.05)) != 0)) {
    return(rownames(subset(an,`Pr(>Chi)`<0.05)))
  } else {
    return("Prediction makes no sense")
  }
}
get_features(test_data_03)

# Продолжим нашу работу в службе безопасности! 
# Разобравшись с тем, какие предикторы могут помогать нам 
# предсказывать запрещенный багаж, давайте применим наши знания 
# для повышения безопасности в аэропорту. Обучим наш алгоритм различать 
# запрещенный и разрешенный багаж на уже имеющихся данных и применим 
# его для сканирования нового багажа!
# Напишите функцию, которая принимает на вход два набора данных. 
# Первый dataframe, как и в предыдущей задаче, содержит информацию 
# об уже осмотренном багаже (запрещенный или нет, вес, длина, ширина, тип сумки). 
# Второй набор данных — это информация о новом багаже,
# который сканируется прямо сейчас. В данных также есть информация: 
# вес, длина, ширина, тип сумки и имя пассажира (смотри описание переменных в примере). 
# Используя первый набор данных, обучите регрессионную модель
# различать запрещенный и разрешенный багаж. 
# При помощи полученной модели для каждого наблюдения в новых данных 
# предскажите вероятность того, что багаж является запрещенным. 
# Пассажиров, чей багаж получил максимальное значение вероятности,
# мы попросим пройти дополнительную проверку. 
# Итого, ваша функция принимает два набора данных и возвращает имя 
# пассажира с наиболее подозрительным багажом. Если несколько пассажиров 
# получили максимальное значение вероятности, то верните вектор с несколькими именами. 
# В этой задаче для предсказания будем использовать все предикторы, 
# даже если некоторые из них оказались незначимыми. 
# Для предсказания стройте модель без взаимодействия предикторов.

test_data_04 <- read.csv("https://stepic.org/media/attachments/course/524/test_data_passangers.csv")
data_for_predict <-read.csv("https://stepic.org/media/attachments/course/524/predict_passangers.csv")


most_suspicious <- function(test_data, data_for_predict){
  test_data$is_prohibited <- as.factor(test_data$is_prohibited)
  test_data$type <- as.factor(test_data$type)
  data_for_predict$type <- as.factor(data_for_predict$type)
  lg_04 <- glm(is_prohibited ~ ., data=test_data, family=binomial)
  y_pred <- predict.glm(lg_04, newdata = data_for_predict[, 1:4], type="response")
  data_for_predict$passangers[which(y_pred == max(y_pred))]
}
most_suspicious(test_data_04, data_for_predict)


# Напишите функцию normality_test, которая получает на вход dataframe с 
# произвольным количеством переменных разных типов (количественные, строки, факторы)
# и проверяет нормальность распределения количественных переменных. 
# Функция должна возвращать вектор значений p-уровней значимости теста 
# shapiro.test для каждой количественной переменной.

test_05 <- read.csv("https://stepic.org/media/attachments/course/524/test.csv")
unlist(lapply(test_05,is.numeric))


# Напишите функцию normality_by, которая принимает на вход dataframe 
# c тремя переменными. Первая переменная количественная, 
# вторая и третья имеют две градации и разбивают наши наблюдения 
# на группы. Функция должна проверять распределение на 
# нормальность в каждой получившейся группе и возвращать 
# dataframe с результатами применения теста shapiro.test 
# (формат вывода смотри ниже).


test_data_06 <- read.csv("https://stepic.org/media/attachments/course/524/test_for_norm.csv", stringsAsFactors = T)
test_data_06$y <- as.factor(test_data_06$y)
test_data_06$z <- as.factor(test_data_06$z)
gr_data_06 <- test_data_06 %>% 
  group_by(y, z)
summarise(gr_data_06, 
          p_value = shapiro.test(x)$p.value)

normality_by <- function(test){
  test$y <- as.factor(test$y)
  test$z <- as.factor(test$z)
  gr_data_06 <- test %>% 
    group_by(y, z)
  summarise(gr_data_06, 
            p_value = shapiro.test(x)$p.value) 
}

normality_by(test_data_06)


# При помощи библиотеки ggplot2 визуализируйте распределение
# переменной Sepal.Length в трех группах в данных Iris. 
# Сохраните график в переменную obj, но не выводите график на печать.



ggplot(iris, aes(x=Sepal.Length, fill=Species))+
  geom_density(alpha=0.2)


