# Напишите функцию smart_hclust, которая получает на вход 
# dataframe  с произвольным числом количественных переменных 
# и число кластеров, которое необходимо выделить при помощи 
# иерархической кластеризации.
# Функция должна в исходный набор данных добавлять новую 
# переменную фактор - cluster  -- номер кластера, 
# к которому отнесено каждое из наблюдений.

test_data_01 <- read.csv("https://stepic.org/media/attachments/course/524/test_data_hclust.csv")


smart_hclust<-  function(test_data, cluster_number){
  dist_matrix <- dist(test_data)
  fit <- hclust(dist_matrix)
  cluster <- as.factor(cutree(fit, cluster_number))
  test_data$claster <- cluster
  return(test_data)
}

smart_hclust(test_data_01, 3)


# Интересной особенностью кластерного анализа является тот факт, 
# что мы получаем только итоговый ответ, к какому кластеру принадлежит
# каждое наблюдение. Однако мы не знаем, по каким переменным различаются 
# выделенные кластеры. Поэтому, если нас интересует не 
# только сам факт того, что мы смогли выделить кластеры в наших 
# данных, но мы также хотим понять, чем же они различаются, 
# разумно сравнить кластеры между собой по имеющимся переменным.
# Напишите функцию get_difference, которая получает на вход два аргумента: 
  # test_data — набор данных с произвольным числом количественных переменных.
  # n_cluster — число кластеров, которое нужно выделить в данных при 
# помощи иерархической кластеризации.
# Функция должна вернуть названия переменных, 
# по которым были обнаружен значимые различия между выделенными
# кластерами (p < 0.05).
# Иными словами, после того,
# как мы выделили заданное число кластеров, 
# мы добавляем в исходные данные новую группирующую переменную 
# — номер кластера, и сравниваем получившиеся группы 
# между собой по количественным переменным при помощи дисперсионного анализа.

test_data_02 <- read.csv("https://stepic.org/media/attachments/course/524/cluster_2.csv")
  dist_matrix <- dist(test_data_02)
  fit <- hclust(dist_matrix)
  cluster <- as.factor(cutree(fit, 4))
  test_data_02$cluster <- cluster
grouped <- test_data_02 %>% 
  group_by(cluster)
apply(grouped, 2, function(x) aov(x ~ cluster)$p.value)
summary(aov(V1 ~ cluster, grouped))[1]
